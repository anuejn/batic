
module.exports = class FragmentShaderRenderer {
    /**
     * Initializes a new fragment shader renderer for the given canvas
     * @param canvas the canvas for rendering
     * @param options an object with the fields {size: {x: number, y: number}}
     */
    constructor(canvas, options) {
        this.options = options;

        this.canvas = canvas;
        this.gl = canvas.getContext("webgl2");
        let gl = this.gl;
        this.program = gl.createProgram();



    }

    /**
     * renders the current shader. this method should be called after every e
     */
    render() {

    }

    /**
     * sets the fragment shader code, that should be rendered to the canvas
     * @param code the glsl code of the fragment shader
     */
    setFragmentShader(code) {
        let gl = this.gl;

        this.fragment_shader_code = code;

        gl.detachShader(this.program, this.fragment_shader);
        this.fragment_shader = this._createShader(gl.FRAGMENT_SHADER, this.fragment_shader_code);
        gl.attachShader(this.program, this.fragment_shader);

        gl.linkProgram(this.program);
        let success = gl.getProgramParameter(this.program, gl.LINK_STATUS);
        if (!success) {
            console.log(this.gl.getProgramInfoLog(this.program));
        }
    }

    /**
     * sets a texture for the FragmentShaderRenderer
     * @param name the name of the sampler2D
     * @param data the data of the texture
     * @param size the size of the texture in the form {x: number, y: number}
     * @param options the options for the texture sampler
     */
    setTexture2D(name, data, size, options) {
        let gl = this.gl;
        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        Object.keys(options).forEach(k => {
            gl.texParameteri(gl.TEXTURE_2D, this._getGlConst(k), this._getGlConst(options[k]));
        });
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, size.x, size.y, 0, gl.RED, gl.FLOAT, data);
    }

    /**
     * sets a uniform for the FragmentShaderRenderer
     * @param name the mane of the uniform
     * @param type the type of the uniform ie. uniform1f
     * @param data the data that should be in the uniform
     */
    setUniform(name, type, data) {
        gl.useProgram(this.program);
        let loc = gl.getUniformLocation(program, name);
        this._getGlConst(type)(loc, data);
    }



    _createShader(type, source) {
        let gl = this.gl;

        let shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

        if (success) {
            return shader;
        } else {
            gl.deleteShader(shader);
            throw {type: "compilation error", payload: gl.getShaderInfoLog(shader)};
        }
    }

    _setVertexAttribute(name, data) {
        let gl = this.gl;

        let attributeLocation = gl.getAttribLocation(this.program, name);
        let buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attributeLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        return attributeLocation;
    }

    _getGlConst(name) {
        return this.gl[name];
    }
};




const size = {x: 4096, y: 3072};


const fsr = new FragmentShaderRenderer(document.querySelector("#canvas"), {size: size});
async function main() {
    const shader = await loaders.loadText("examples/shaders/black_white.glsl");
    const raw_image = await loaders.loadRaw16("examples/images/human.raw16");


    window.code.setValue(shader, -1);

    let redo = () => {
        generate_inputs(window.code.getSession().getValue());
        setup(window.code.getSession().getValue(), raw_image, size)
    };
    window.code.getSession().on('change', () => setTimeout(redo, 10)); // the setTimeout is for not slowing the editor down or throwing errors from the event handler

    document.getElementById("loading").style.display = "none";
    redo();
}

function generate_inputs(src) {
    let inputs = "";
    let input_values = get_inputs_values();
    src.replace(/uniform float (.*);/g, (_, x) => {inputs += `<label>${x} <input type="range" min="0" max="1" value="0.5" step="0.000001" class="slider" id="slider_${x}"></label>\n`});
    document.querySelector("#controls").innerHTML = inputs;
    Object.keys(input_values).forEach(name => {
        document.getElementById("input_" + name).value = input_values[name];
    });
    Array.from(document.getElementsByTagName("input")).forEach(s => s.oninput = () => {
        let vals = get_inputs_values();
        Object.keys(vals).forEach(val_name => {
            fsr.setUniform(val_name, 'uniform1f', vals[val_name]);
        });
        fsr.render();
    })
}

function get_inputs_values() {
    let input_values = {};
    Array.from(document.getElementsByTagName("input")).forEach(slider => {
        input_values[slider.id.replace("input_", "")] = parseFloat(slider.value);
    });
    return input_values;
}


function setup(fragment_shader_code, raw_image, canvas_size) {
    fsr.setFragmentShader(fragment_shader_code);
    fsr.setTexture2D("", raw_image, canvas_size, {
        TEXTURE_MAG_FILTER: 'NEAREST',
        TEXTURE_MIN_FILTER: 'NEAREST',
        TEXTURE_WRAP_S: 'CLAMP_TO_EDGE',
        TEXTURE_WRAP_T: 'CLAMP_TO_EDGE',
    });
    fsr.render();
}